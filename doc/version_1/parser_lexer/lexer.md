## Lexer

The lexer defines how the contents of a source file for our language is tokenised, broken into
individual tokens, used by the parser.

Their have been various ways to define lexers in the past, using programs like `Flex` [@FLEX] or `Lex` [@LEX], which was written by the former CEO of Google Eric Schmidt. IntelliJ recommends to use `JFlex` [@JFLEX], which we will.

The steps for creating a lexer for the IntelliJ Platform are:

+ Define a lexer using the `JFlex` lexer definition syntax and generate the lexer class from it.
+ Create a `FlexAdapter`, which will help interpret the lexer class for our plugin.
+ Define a base PSI element representing the file being lexed and parsed.
+ Define the parser definition, we did not do this in the previous part since we need the lexer to
  fully implement it.
+ Register the parser definition with the plugin.

### Lexer definition

A `JFlex` lexer definition has 3 main elements in the file, separated into 3 section delimited between
them using `%%` has separator, these sections are:

+ User code, depicted in listing \ref{flex:user}, everything in this section is copied verbatim to the resulting lexer class, we normally
  include `package` and `import` statements.
+ Options and macros, depicted in listing \ref{flex:options}, in this section we define options for the generated lexer class, like the name
  of the class, which class it extends. We also define macros used later in the rules section, these
   macros behave like C preprocessor macros. The final part of this section is defining the possible
   lexical states available.
+ Rules and actions, depicted in listing \ref{flex:rules}, this section is the main part of the lexer. We define how the scanner matches
  the input using regular expressions and lexical states, more detailed information is available in
  the `JFlex` Manual [@JFLEXMAN].

\begin{listing}[h]
\inputminted[firstline=1, lastline=8, breaklines, autogobble, fontsize=\footnotesize]{text}{code-source/ch/eif/intelliprolog/Prolog.flex}
\caption{User code in Flex file}
\label{flex:user}
\end{listing}

\begin{listing}[h]
\inputminted[firstline=8, lastline=16, breaklines, autogobble, fontsize=\footnotesize, linenos]{text}{code-source/ch/eif/intelliprolog/Prolog.flex}
\inputminted[firstline=60, lastline=70, breaklines, autogobble, fontsize=\footnotesize, linenos]{text}{code-source/ch/eif/intelliprolog/Prolog.flex}
\inputminted[firstline=87, lastline=90, breaklines, autogobble, fontsize=\footnotesize, linenos]{text}{code-source/ch/eif/intelliprolog/Prolog.flex}
\caption{Options, macros and lexical states in Flex file}
\label{flex:options}
\end{listing}

\begin{listing}[h]
\inputminted[firstline=106, lastline=112, breaklines, autogobble, fontsize=\footnotesize, autogobble]{text}{code-source/ch/eif/intelliprolog/Prolog.flex}
\caption{Extract from rules and actions part of Flex file}
\label{flex:rules}
\end{listing}

As with the parser definition we are also using the definition from the logtalk3 intellij plugin [@lgt3plug], this for the same reasons
detailed for the parser.

#### Generate lexer class

Generating the lexer class is similar to generating the parser class, we just have to click on `Run JFlex Generator` in the context menu for the flexe definition file.

If it is the first time that the generator is run, IDEA will offer to download the JFlex generator as
well as a skeleton file detailing how it should be run. This should be saved in the project root directory.

### FlexAdapter

The `FlexAdapter` class will be called `PrologLexerAdapter`, visible in listing \ref{code:PrologLexerAdapter}, for our plugin and extends the `FlexAdapter` class [@FLEXADAPT] provided by JetBrains.

The only thing we need to implement in this class is a constructor that calls the super class
constructor with our lexer class.

\begin{listing}[h]
\inputminted[breaklines, autogobble, fontsize=\footnotesize]{java}{code-source/ch/eif/intelliprolog/PrologLexerAdapter.java}
\caption{PrologLexerAdapter class}
\label{code:PrologLexerAdapter}
\end{listing}

### Root PSI file

The root PSI file class represents a file that belongs to our language and is used as the root element
in the PSI tree generated by our parser and lexer after going through our source file.

The class that we will call `PrologFile`, depicted in listing \ref{code:PrologFile}, extends the `PsiFileBase` class [@PFB],
and has a constructor calling the super class constructor with the `FileViewProvider` argument and
the instance of our `PrologLanguage` class.

We also override the `FileType getFileType()` method returning the instance of our `PrologFileType` and override the `toString()` method returning `Prolog File`.

\begin{listing}[h]
\inputminted[breaklines, autogobble, fontsize=\footnotesize]{java}{code-source/ch/eif/intelliprolog/psi/PrologFile.java}
\caption{PrologFile class}
\label{code:PrologFile}
\end{listing}

### Parser Definition

The parser definition class, called `PrologParserDefinition` visible in listing \ref{code:PrologParserDefinition} implements the `ParserDefinition` [@PARSDEF], and defines the implementation of a custom
language parser.

This class is where we define which parser, lexer, PSI file base and elements to be used in our parser,
to accomplish this we need to implement the methods defined in `ParserDefinition`.

These methods are:

+ `Lexer createLexer(Project project)`, returns the lexer we want to use for lexing our files, we
  return the `PrologLexerAdapter`.
+ `PsiParser createParser(Project project)`, returns the parser we want to use for parsing our files,
  we return the generated `PrologParser`.
+ `IFileElementType getFileNodeType()`, returns the element type for a file in the specified language,
  we return an `IFileElementType` with the instance of `PrologLanguage`.
+ `TokenSet getCommentTokens()`, returns a set of token types representing comments in our language,
  we return a `TokenSet` created from the comment type of our parser.
+ `TokenSet getStringLiteralElements()`, returns a set of token types representing string literals in
  our language, we return a `TokenSet` created from the string type of our parser.
+ `PsiElement createElement(ASTNode node)`, returns the appropriate `PsiElement` for a given `ASTNode`,
  we use the factory generated from our parser.
+ `PsiFile createFile(FileViewProvider viewProvider)`, returns the root PSI element of the virtual file,
  we return a `PrologFile` instance.
+ `SpaceRequirements spaceExistanceTypeBetweenTokens(ASTNode left, ASTNode right)`, checks if the two
  tokens need a space between them, we return `SpaceRequirements.MAY`

\begin{listing}[h]
\inputminted[breaklines, autogobble, fontsize=\footnotesize, firstline=18, lastline=68]{java}{code-source/ch/eif/intelliprolog/PrologParserDefinition.java}
\caption{PrologParserDefinition}
\label{code:PrologParserDefinition}
\end{listing}

### Register the parser definition

The `ParserDefinition` needs to be added to the extensions section of the `plugin.xml` file,
the element that needs to be added is visible in listing \ref{reg:parserdefinition}.

\begin{listing}[h]
\inputminted[breaklines, autogobble, fontsize=\footnotesize,firstline=31, lastline=31]{xml}{code-resources/META-INF/plugin.xml}
\caption{ParserDefinition registration}
\label{reg:parserdefinition}
\end{listing}
